"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SplitChainDescriptorEnum = exports.ClaimRewardsChainDescriptorEnum = exports.StakingApi = exports.StakingApiFactory = exports.StakingApiFp = exports.StakingApiAxiosParamCreator = void 0;
var axios_1 = __importDefault(require("axios"));
var fireblocksResponse_1 = require("../response/fireblocksResponse");
// URLSearchParams not necessarily used
// @ts-ignore
var url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("../common");
var validation_utils_1 = require("../utils/validation_utils");
// @ts-ignore
var base_1 = require("../base");
/**
 * StakingApi - axios parameter creator
 * @export
 */
var StakingApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
         * @summary Approve staking terms of service
         * @param {StakingProvider} providerId The unique identifier of the staking provider
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTermsOfServiceByProviderId: function (providerId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('approveTermsOfServiceByProviderId', 'providerId', providerId);
                    localVarPath = "/staking/providers/{providerId}/approveTermsOfService"
                        .replace("{".concat("providerId", "}"), encodeURIComponent(String(providerId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Perform a chain-specific Claim Rewards.
         * @summary Execute a Claim Rewards operation
         * @param {ClaimRewardsRequest} claimRewardsRequest
         * @param {ClaimRewardsChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;MATIC\&quot;/\&quot;SOL\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimRewards: function (claimRewardsRequest, chainDescriptor, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('claimRewards', 'claimRewardsRequest', claimRewardsRequest);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('claimRewards', 'chainDescriptor', chainDescriptor);
                    localVarPath = "/staking/chains/{chainDescriptor}/claim_rewards"
                        .replace("{".concat("chainDescriptor", "}"), encodeURIComponent(String(chainDescriptor)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(claimRewardsRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
         * @summary List staking positions details
         * @param {ChainDescriptor} [chainDescriptor] Use \&quot;ETH\&quot; / \&quot;SOL\&quot; / \&quot;MATIC\&quot; / \&quot;STETH_ETH\&quot; in order to obtain information related to the specific blockchain network or retrieve information about all chains that have data available by providing no argument.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDelegations: function (chainDescriptor, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/staking/positions";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (chainDescriptor !== undefined) {
                        localVarQueryParameter['chainDescriptor'] = chainDescriptor;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
         * @summary Get chain-specific staking summary
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;/\&quot;STETH_ETH\&quot;) to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo: function (chainDescriptor, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('getChainInfo', 'chainDescriptor', chainDescriptor);
                    localVarPath = "/staking/chains/{chainDescriptor}/chainInfo"
                        .replace("{".concat("chainDescriptor", "}"), encodeURIComponent(String(chainDescriptor)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return an alphabetical list of supported chains.
         * @summary List staking supported chains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChains: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/staking/chains";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return detailed information on a staking position, including the staked amount, rewards, status and more.
         * @summary Get staking position details
         * @param {string} id The unique identifier of the staking position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegationById: function (id, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getDelegationById', 'id', id);
                    localVarPath = "/staking/positions/{id}"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return information on all the available staking providers.
         * @summary List staking providers details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/staking/providers";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/staking/positions/summary";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details by vault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryByVault: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/staking/positions/summary/vaults";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Perform a Solana Split stake account.
         * @summary Execute a Split operation on SOL/SOL_TEST stake account
         * @param {SplitRequest} splitRequest
         * @param {SplitChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;SOL\&quot;/\&quot;SOL_TEST\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        split: function (splitRequest, chainDescriptor, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('split', 'splitRequest', splitRequest);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('split', 'chainDescriptor', chainDescriptor);
                    localVarPath = "/staking/chains/{chainDescriptor}/split"
                        .replace("{".concat("chainDescriptor", "}"), encodeURIComponent(String(chainDescriptor)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(splitRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Perform a chain-specific Stake.
         * @summary Initiate Stake Operation
         * @param {StakeRequest} stakeRequest
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stake: function (stakeRequest, chainDescriptor, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('stake', 'stakeRequest', stakeRequest);
                    (0, common_1.assertParamExists)('stake', 'chainDescriptor', chainDescriptor);
                    localVarPath = "/staking/chains/{chainDescriptor}/stake"
                        .replace("{".concat("chainDescriptor", "}"), encodeURIComponent(String(chainDescriptor)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(stakeRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Execute an Unstake operation
         * @summary Execute an Unstake operation
         * @param {UnstakeRequest} unstakeRequest
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstake: function (unstakeRequest, chainDescriptor, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('unstake', 'unstakeRequest', unstakeRequest);
                    (0, common_1.assertParamExists)('unstake', 'chainDescriptor', chainDescriptor);
                    localVarPath = "/staking/chains/{chainDescriptor}/unstake"
                        .replace("{".concat("chainDescriptor", "}"), encodeURIComponent(String(chainDescriptor)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(unstakeRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Perform a chain-specific Withdraw.
         * @summary Execute a Withdraw operation
         * @param {WithdrawRequest} withdrawRequest
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdraw: function (withdrawRequest, chainDescriptor, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('withdraw', 'withdrawRequest', withdrawRequest);
                    (0, common_1.assertParamExists)('withdraw', 'chainDescriptor', chainDescriptor);
                    localVarPath = "/staking/chains/{chainDescriptor}/withdraw"
                        .replace("{".concat("chainDescriptor", "}"), encodeURIComponent(String(chainDescriptor)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(withdrawRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.StakingApiAxiosParamCreator = StakingApiAxiosParamCreator;
/**
 * StakingApi - functional programming interface
 * @export
 */
var StakingApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.StakingApiAxiosParamCreator)(configuration);
    return {
        /**
         * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
         * @summary Approve staking terms of service
         * @param {StakingProvider} providerId The unique identifier of the staking provider
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTermsOfServiceByProviderId: function (providerId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.approveTermsOfServiceByProviderId(providerId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.approveTermsOfServiceByProviderId']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Perform a chain-specific Claim Rewards.
         * @summary Execute a Claim Rewards operation
         * @param {ClaimRewardsRequest} claimRewardsRequest
         * @param {ClaimRewardsChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;MATIC\&quot;/\&quot;SOL\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimRewards: function (claimRewardsRequest, chainDescriptor, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.claimRewards(claimRewardsRequest, chainDescriptor, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.claimRewards']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
         * @summary List staking positions details
         * @param {ChainDescriptor} [chainDescriptor] Use \&quot;ETH\&quot; / \&quot;SOL\&quot; / \&quot;MATIC\&quot; / \&quot;STETH_ETH\&quot; in order to obtain information related to the specific blockchain network or retrieve information about all chains that have data available by providing no argument.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDelegations: function (chainDescriptor, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAllDelegations(chainDescriptor, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.getAllDelegations']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
         * @summary Get chain-specific staking summary
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;/\&quot;STETH_ETH\&quot;) to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo: function (chainDescriptor, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getChainInfo(chainDescriptor, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.getChainInfo']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return an alphabetical list of supported chains.
         * @summary List staking supported chains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChains: function (options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getChains(options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.getChains']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return detailed information on a staking position, including the staked amount, rewards, status and more.
         * @summary Get staking position details
         * @param {string} id The unique identifier of the staking position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegationById: function (id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDelegationById(id, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.getDelegationById']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return information on all the available staking providers.
         * @summary List staking providers details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: function (options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getProviders(options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.getProviders']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary: function (options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSummary(options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.getSummary']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details by vault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryByVault: function (options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSummaryByVault(options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.getSummaryByVault']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Perform a Solana Split stake account.
         * @summary Execute a Split operation on SOL/SOL_TEST stake account
         * @param {SplitRequest} splitRequest
         * @param {SplitChainDescriptorEnum} chainDescriptor The protocol identifier (e.g. \&quot;SOL\&quot;/\&quot;SOL_TEST\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        split: function (splitRequest, chainDescriptor, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.split(splitRequest, chainDescriptor, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.split']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Perform a chain-specific Stake.
         * @summary Initiate Stake Operation
         * @param {StakeRequest} stakeRequest
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stake: function (stakeRequest, chainDescriptor, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.stake(stakeRequest, chainDescriptor, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.stake']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Execute an Unstake operation
         * @summary Execute an Unstake operation
         * @param {UnstakeRequest} unstakeRequest
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstake: function (unstakeRequest, chainDescriptor, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unstake(unstakeRequest, chainDescriptor, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.unstake']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Perform a chain-specific Withdraw.
         * @summary Execute a Withdraw operation
         * @param {WithdrawRequest} withdrawRequest
         * @param {ChainDescriptor} chainDescriptor The protocol identifier (e.g. \&quot;ETH\&quot;/\&quot;SOL\&quot;/\&quot;MATIC\&quot;) to use
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdraw: function (withdrawRequest, chainDescriptor, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.withdraw(withdrawRequest, chainDescriptor, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['StakingApi.withdraw']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
    };
};
exports.StakingApiFp = StakingApiFp;
/**
 * StakingApi - factory interface
 * @export
 */
var StakingApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.StakingApiFp)(configuration);
    return {
        /**
         * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
         * @summary Approve staking terms of service
         * @param {StakingApiApproveTermsOfServiceByProviderIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveTermsOfServiceByProviderId: function (requestParameters, options) {
            return localVarFp.approveTermsOfServiceByProviderId(requestParameters.providerId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Perform a chain-specific Claim Rewards.
         * @summary Execute a Claim Rewards operation
         * @param {StakingApiClaimRewardsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimRewards: function (requestParameters, options) {
            return localVarFp.claimRewards(requestParameters.claimRewardsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
         * @summary List staking positions details
         * @param {StakingApiGetAllDelegationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDelegations: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getAllDelegations(requestParameters.chainDescriptor, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
         * @summary Get chain-specific staking summary
         * @param {StakingApiGetChainInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo: function (requestParameters, options) {
            return localVarFp.getChainInfo(requestParameters.chainDescriptor, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return an alphabetical list of supported chains.
         * @summary List staking supported chains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChains: function (options) {
            return localVarFp.getChains(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return detailed information on a staking position, including the staked amount, rewards, status and more.
         * @summary Get staking position details
         * @param {StakingApiGetDelegationByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegationById: function (requestParameters, options) {
            return localVarFp.getDelegationById(requestParameters.id, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return information on all the available staking providers.
         * @summary List staking providers details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: function (options) {
            return localVarFp.getProviders(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummary: function (options) {
            return localVarFp.getSummary(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
         * @summary Get staking summary details by vault
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSummaryByVault: function (options) {
            return localVarFp.getSummaryByVault(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Perform a Solana Split stake account.
         * @summary Execute a Split operation on SOL/SOL_TEST stake account
         * @param {StakingApiSplitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        split: function (requestParameters, options) {
            return localVarFp.split(requestParameters.splitRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Perform a chain-specific Stake.
         * @summary Initiate Stake Operation
         * @param {StakingApiStakeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stake: function (requestParameters, options) {
            return localVarFp.stake(requestParameters.stakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Execute an Unstake operation
         * @summary Execute an Unstake operation
         * @param {StakingApiUnstakeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstake: function (requestParameters, options) {
            return localVarFp.unstake(requestParameters.unstakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Perform a chain-specific Withdraw.
         * @summary Execute a Withdraw operation
         * @param {StakingApiWithdrawRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdraw: function (requestParameters, options) {
            return localVarFp.withdraw(requestParameters.withdrawRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.StakingApiFactory = StakingApiFactory;
/**
 * StakingApi - object-oriented interface
 * @export
 * @class StakingApi
 * @extends {BaseAPI}
 */
var StakingApi = /** @class */ (function (_super) {
    __extends(StakingApi, _super);
    function StakingApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Approve the terms of service of the staking provider. This must be called before performing a staking action for the first time with this provider.
     * @summary Approve staking terms of service
     * @param {StakingApiApproveTermsOfServiceByProviderIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.approveTermsOfServiceByProviderId = function (requestParameters) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).approveTermsOfServiceByProviderId(requestParameters.providerId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Perform a chain-specific Claim Rewards.
     * @summary Execute a Claim Rewards operation
     * @param {StakingApiClaimRewardsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.claimRewards = function (requestParameters) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).claimRewards(requestParameters.claimRewardsRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return detailed information on all staking positions, including the staked amount, rewards, status and more.
     * @summary List staking positions details
     * @param {StakingApiGetAllDelegationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.getAllDelegations = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.StakingApiFp)(this.configuration).getAllDelegations(requestParameters.chainDescriptor).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return chain-specific, staking-related information summary (e.g. epoch details, lockup durations, estimated rewards, etc.)
     * @summary Get chain-specific staking summary
     * @param {StakingApiGetChainInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.getChainInfo = function (requestParameters) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).getChainInfo(requestParameters.chainDescriptor).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return an alphabetical list of supported chains.
     * @summary List staking supported chains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.getChains = function () {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).getChains().then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return detailed information on a staking position, including the staked amount, rewards, status and more.
     * @summary Get staking position details
     * @param {StakingApiGetDelegationByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.getDelegationById = function (requestParameters) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).getDelegationById(requestParameters.id).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return information on all the available staking providers.
     * @summary List staking providers details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.getProviders = function () {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).getProviders().then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return a summary of all vaults, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
     * @summary Get staking summary details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.getSummary = function () {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).getSummary().then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return a summary for each vault, categorized by their status (active, inactive), the total amounts staked and total rewards per-chain.
     * @summary Get staking summary details by vault
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.getSummaryByVault = function () {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).getSummaryByVault().then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Perform a Solana Split stake account.
     * @summary Execute a Split operation on SOL/SOL_TEST stake account
     * @param {StakingApiSplitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.split = function (requestParameters) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).split(requestParameters.splitRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Perform a chain-specific Stake.
     * @summary Initiate Stake Operation
     * @param {StakingApiStakeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.stake = function (requestParameters) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).stake(requestParameters.stakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Execute an Unstake operation
     * @summary Execute an Unstake operation
     * @param {StakingApiUnstakeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.unstake = function (requestParameters) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).unstake(requestParameters.unstakeRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Perform a chain-specific Withdraw.
     * @summary Execute a Withdraw operation
     * @param {StakingApiWithdrawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    StakingApi.prototype.withdraw = function (requestParameters) {
        var _this = this;
        return (0, exports.StakingApiFp)(this.configuration).withdraw(requestParameters.withdrawRequest, requestParameters.chainDescriptor, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    return StakingApi;
}(base_1.BaseAPI));
exports.StakingApi = StakingApi;
/**
 * @export
 */
exports.ClaimRewardsChainDescriptorEnum = {
    Matic: 'MATIC',
    Sol: 'SOL',
    SolTest: 'SOL_TEST'
};
/**
 * @export
 */
exports.SplitChainDescriptorEnum = {
    Sol: 'SOL',
    SolTest: 'SOL_TEST'
};
//# sourceMappingURL=staking-api.js.map