"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetPublicKeyInfoNcwAlgorithmEnum = exports.GetEmbeddedWalletsOrderEnum = exports.GetEmbeddedWalletsSortEnum = exports.GetEmbeddedWalletAddressesOrderEnum = exports.GetEmbeddedWalletAddressesSortEnum = exports.EmbeddedWalletsApi = exports.EmbeddedWalletsApiFactory = exports.EmbeddedWalletsApiFp = exports.EmbeddedWalletsApiAxiosParamCreator = void 0;
var axios_1 = __importDefault(require("axios"));
var fireblocksResponse_1 = require("../response/fireblocksResponse");
// URLSearchParams not necessarily used
// @ts-ignore
var url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("../common");
var validation_utils_1 = require("../utils/validation_utils");
// @ts-ignore
var base_1 = require("../base");
/**
 * EmbeddedWalletsApi - axios parameter creator
 * @export
 */
var EmbeddedWalletsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Get the addresses of a specific asset, under a specific account, under a specific Non Custodial Wallet
         * @summary Add asset to account
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmbeddedWalletAsset: function (walletId, accountId, assetId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('addEmbeddedWalletAsset', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('addEmbeddedWalletAsset', 'accountId', accountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('addEmbeddedWalletAsset', 'assetId', assetId);
                    localVarPath = "/ncw/wallets/{walletId}/accounts/{accountId}/assets/{assetId}"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)))
                        .replace("{".concat("accountId", "}"), encodeURIComponent(String(accountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Create new Non Custodial Wallet
         * @summary Create a new wallet
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedWallet: function (idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/ncw/wallets";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Create a new account under a specific Non Custodial Wallet
         * @summary Create a new account
         * @param {string} walletId Wallet Id
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedWalletAccount: function (walletId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('createEmbeddedWalletAccount', 'walletId', walletId);
                    localVarPath = "/ncw/wallets/{walletId}/accounts"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get a wallet
         * @summary Get a wallet
         * @param {string} walletId Wallet Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWallet: function (walletId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWallet', 'walletId', walletId);
                    localVarPath = "/ncw/wallets/{walletId}"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get a specific account under a specific Non Custodial Wallet
         * @summary Get a account
         * @param {string} walletId WalletId
         * @param {string} accountId The ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAccount: function (walletId, accountId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAccount', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAccount', 'accountId', accountId);
                    localVarPath = "/ncw/wallets/{walletId}/accounts/{accountId}"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)))
                        .replace("{".concat("accountId", "}"), encodeURIComponent(String(accountId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get the addresses of a specific asset, under a specific account, under a specific Non Custodial Wallet
         * @summary Retrieve asset addresses
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {string} [pageCursor] Cursor to the next page
         * @param {number} [pageSize] Items per page
         * @param {GetEmbeddedWalletAddressesSortEnum} [sort] Sort by address
         * @param {GetEmbeddedWalletAddressesOrderEnum} [order] Is the order ascending or descending
         * @param {boolean} [enabled] Enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAddresses: function (walletId, accountId, assetId, pageCursor, pageSize, sort, order, enabled, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAddresses', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAddresses', 'accountId', accountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAddresses', 'assetId', assetId);
                    localVarPath = "/ncw/wallets/{walletId}/accounts/{accountId}/assets/{assetId}/addresses"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)))
                        .replace("{".concat("accountId", "}"), encodeURIComponent(String(accountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (sort !== undefined) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (enabled !== undefined) {
                        localVarQueryParameter['enabled'] = enabled;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get asset under a specific account, under a specific Non Custodial Wallet
         * @summary Retrieve asset
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAsset: function (walletId, accountId, assetId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAsset', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAsset', 'accountId', accountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAsset', 'assetId', assetId);
                    localVarPath = "/ncw/wallets/{walletId}/accounts/{accountId}/assets/{assetId}"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)))
                        .replace("{".concat("accountId", "}"), encodeURIComponent(String(accountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get balance for specific asset, under a specific account
         * @summary Retrieve asset balance
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAssetBalance: function (walletId, accountId, assetId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAssetBalance', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAssetBalance', 'accountId', accountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletAssetBalance', 'assetId', assetId);
                    localVarPath = "/ncw/wallets/{walletId}/accounts/{accountId}/assets/{assetId}/balance"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)))
                        .replace("{".concat("accountId", "}"), encodeURIComponent(String(accountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get specific device for a specific s Wallet
         * @summary Get Embedded Wallet Device
         * @param {string} walletId Wallet Id
         * @param {string} deviceId Device Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletDevice: function (walletId, deviceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletDevice', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletDevice', 'deviceId', deviceId);
                    localVarPath = "/ncw/wallets/{walletId}/devices/{deviceId}"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)))
                        .replace("{".concat("deviceId", "}"), encodeURIComponent(String(deviceId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get the state of the specific device setup key under a specific Non Custodial Wallet
         * @summary Get device key setup state
         * @param {string} walletId Wallet Id
         * @param {string} deviceId Device Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletDeviceSetupState: function (walletId, deviceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletDeviceSetupState', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletDeviceSetupState', 'deviceId', deviceId);
                    localVarPath = "/ncw/wallets/{walletId}/devices/{deviceId}/setup_status"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)))
                        .replace("{".concat("deviceId", "}"), encodeURIComponent(String(deviceId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get wallet Latest Backup details, including the deviceId, and backup time
         * @summary Get wallet Latest Backup details
         * @param {string} walletId Wallet Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletLatestBackup: function (walletId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletLatestBackup', 'walletId', walletId);
                    localVarPath = "/ncw/wallets/{walletId}/backup/latest"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Gets the public key of an asset associated with a specific account within a Non-Custodial Wallet
         * @summary Get the public key of an asset
         * @param {string} xEndUserWalletId Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} walletId The ID of the Non-Custodial wallet
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {number} change BIP44 derivation path - change value
         * @param {number} addressIndex BIP44 derivation path - index value
         * @param {boolean} [compressed] Compressed/Uncompressed public key format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletPublicKeyInfoForAddress: function (xEndUserWalletId, walletId, accountId, assetId, change, addressIndex, compressed, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletPublicKeyInfoForAddress', 'xEndUserWalletId', xEndUserWalletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletPublicKeyInfoForAddress', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletPublicKeyInfoForAddress', 'accountId', accountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getEmbeddedWalletPublicKeyInfoForAddress', 'assetId', assetId);
                    (0, common_1.assertParamExists)('getEmbeddedWalletPublicKeyInfoForAddress', 'change', change);
                    (0, common_1.assertParamExists)('getEmbeddedWalletPublicKeyInfoForAddress', 'addressIndex', addressIndex);
                    localVarPath = "/ncw/wallets/{walletId}/accounts/{accountId}/assets/{assetId}/{change}/{addressIndex}/public_key_info"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)))
                        .replace("{".concat("accountId", "}"), encodeURIComponent(String(accountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)))
                        .replace("{".concat("change", "}"), encodeURIComponent(String(change)))
                        .replace("{".concat("addressIndex", "}"), encodeURIComponent(String(addressIndex)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (compressed !== undefined) {
                        localVarQueryParameter['compressed'] = compressed;
                    }
                    if (xEndUserWalletId != null) {
                        localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get all the available supported assets for the Non-Custodial Wallet
         * @summary Retrieve supported assets
         * @param {string} [pageCursor] Next page cursor to fetch
         * @param {number} [pageSize] Items per page
         * @param {boolean} [onlyBaseAssets] Only base assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletSupportedAssets: function (pageCursor, pageSize, onlyBaseAssets, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/ncw/wallets/supported_assets";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (onlyBaseAssets !== undefined) {
                        localVarQueryParameter['onlyBaseAssets'] = onlyBaseAssets;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get all Non Custodial Wallets
         * @summary List wallets
         * @param {string} [pageCursor] Next page cursor to fetch
         * @param {number} [pageSize] Items per page
         * @param {GetEmbeddedWalletsSortEnum} [sort] Field(s) to use for sorting
         * @param {GetEmbeddedWalletsOrderEnum} [order] Is the order ascending or descending
         * @param {boolean} [enabled] Enabled Wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWallets: function (pageCursor, pageSize, sort, order, enabled, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/ncw/wallets";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (sort !== undefined) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (enabled !== undefined) {
                        localVarQueryParameter['enabled'] = enabled;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm within a Non-Custodial Wallet
         * @summary Get the public key for a derivation path
         * @param {string} xEndUserWalletId Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} walletId The ID of the Non-Custodial wallet
         * @param {string} derivationPath An array of integers (passed as JSON stringified array) representing the full BIP44 derivation path of the requested public key.  The first element must always be 44.
         * @param {GetPublicKeyInfoNcwAlgorithmEnum} algorithm Elliptic Curve
         * @param {boolean} [compressed] Compressed/Uncompressed public key format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfoNcw: function (xEndUserWalletId, walletId, derivationPath, algorithm, compressed, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getPublicKeyInfoNcw', 'xEndUserWalletId', xEndUserWalletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getPublicKeyInfoNcw', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getPublicKeyInfoNcw', 'derivationPath', derivationPath);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getPublicKeyInfoNcw', 'algorithm', algorithm);
                    localVarPath = "/ncw/wallets/{walletId}/public_key_info"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (derivationPath !== undefined) {
                        localVarQueryParameter['derivationPath'] = derivationPath;
                    }
                    if (algorithm !== undefined) {
                        localVarQueryParameter['algorithm'] = algorithm;
                    }
                    if (compressed !== undefined) {
                        localVarQueryParameter['compressed'] = compressed;
                    }
                    if (xEndUserWalletId != null) {
                        localVarHeaderParameter['X-End-User-Wallet-Id'] = String(xEndUserWalletId);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Refresh the balance of an asset in a specific account
         * @summary Refresh asset balance
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshEmbeddedWalletAssetBalance: function (walletId, accountId, assetId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('refreshEmbeddedWalletAssetBalance', 'walletId', walletId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('refreshEmbeddedWalletAssetBalance', 'accountId', accountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('refreshEmbeddedWalletAssetBalance', 'assetId', assetId);
                    localVarPath = "/ncw/wallets/{walletId}/accounts/{accountId}/assets/{assetId}/balance"
                        .replace("{".concat("walletId", "}"), encodeURIComponent(String(walletId)))
                        .replace("{".concat("accountId", "}"), encodeURIComponent(String(accountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.EmbeddedWalletsApiAxiosParamCreator = EmbeddedWalletsApiAxiosParamCreator;
/**
 * EmbeddedWalletsApi - functional programming interface
 * @export
 */
var EmbeddedWalletsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.EmbeddedWalletsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get the addresses of a specific asset, under a specific account, under a specific Non Custodial Wallet
         * @summary Add asset to account
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmbeddedWalletAsset: function (walletId, accountId, assetId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.addEmbeddedWalletAsset(walletId, accountId, assetId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.addEmbeddedWalletAsset']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Create new Non Custodial Wallet
         * @summary Create a new wallet
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedWallet: function (idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createEmbeddedWallet(idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.createEmbeddedWallet']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Create a new account under a specific Non Custodial Wallet
         * @summary Create a new account
         * @param {string} walletId Wallet Id
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedWalletAccount: function (walletId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createEmbeddedWalletAccount(walletId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.createEmbeddedWalletAccount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get a wallet
         * @summary Get a wallet
         * @param {string} walletId Wallet Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWallet: function (walletId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWallet(walletId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWallet']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get a specific account under a specific Non Custodial Wallet
         * @summary Get a account
         * @param {string} walletId WalletId
         * @param {string} accountId The ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAccount: function (walletId, accountId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWalletAccount(walletId, accountId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWalletAccount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get the addresses of a specific asset, under a specific account, under a specific Non Custodial Wallet
         * @summary Retrieve asset addresses
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {string} [pageCursor] Cursor to the next page
         * @param {number} [pageSize] Items per page
         * @param {GetEmbeddedWalletAddressesSortEnum} [sort] Sort by address
         * @param {GetEmbeddedWalletAddressesOrderEnum} [order] Is the order ascending or descending
         * @param {boolean} [enabled] Enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAddresses: function (walletId, accountId, assetId, pageCursor, pageSize, sort, order, enabled, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWalletAddresses(walletId, accountId, assetId, pageCursor, pageSize, sort, order, enabled, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWalletAddresses']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get asset under a specific account, under a specific Non Custodial Wallet
         * @summary Retrieve asset
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAsset: function (walletId, accountId, assetId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWalletAsset(walletId, accountId, assetId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWalletAsset']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get balance for specific asset, under a specific account
         * @summary Retrieve asset balance
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAssetBalance: function (walletId, accountId, assetId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWalletAssetBalance(walletId, accountId, assetId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWalletAssetBalance']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get specific device for a specific s Wallet
         * @summary Get Embedded Wallet Device
         * @param {string} walletId Wallet Id
         * @param {string} deviceId Device Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletDevice: function (walletId, deviceId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWalletDevice(walletId, deviceId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWalletDevice']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get the state of the specific device setup key under a specific Non Custodial Wallet
         * @summary Get device key setup state
         * @param {string} walletId Wallet Id
         * @param {string} deviceId Device Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletDeviceSetupState: function (walletId, deviceId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWalletDeviceSetupState(walletId, deviceId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWalletDeviceSetupState']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get wallet Latest Backup details, including the deviceId, and backup time
         * @summary Get wallet Latest Backup details
         * @param {string} walletId Wallet Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletLatestBackup: function (walletId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWalletLatestBackup(walletId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWalletLatestBackup']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Gets the public key of an asset associated with a specific account within a Non-Custodial Wallet
         * @summary Get the public key of an asset
         * @param {string} xEndUserWalletId Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} walletId The ID of the Non-Custodial wallet
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {number} change BIP44 derivation path - change value
         * @param {number} addressIndex BIP44 derivation path - index value
         * @param {boolean} [compressed] Compressed/Uncompressed public key format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletPublicKeyInfoForAddress: function (xEndUserWalletId, walletId, accountId, assetId, change, addressIndex, compressed, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWalletPublicKeyInfoForAddress(xEndUserWalletId, walletId, accountId, assetId, change, addressIndex, compressed, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWalletPublicKeyInfoForAddress']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get all the available supported assets for the Non-Custodial Wallet
         * @summary Retrieve supported assets
         * @param {string} [pageCursor] Next page cursor to fetch
         * @param {number} [pageSize] Items per page
         * @param {boolean} [onlyBaseAssets] Only base assets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletSupportedAssets: function (pageCursor, pageSize, onlyBaseAssets, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWalletSupportedAssets(pageCursor, pageSize, onlyBaseAssets, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWalletSupportedAssets']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get all Non Custodial Wallets
         * @summary List wallets
         * @param {string} [pageCursor] Next page cursor to fetch
         * @param {number} [pageSize] Items per page
         * @param {GetEmbeddedWalletsSortEnum} [sort] Field(s) to use for sorting
         * @param {GetEmbeddedWalletsOrderEnum} [order] Is the order ascending or descending
         * @param {boolean} [enabled] Enabled Wallets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWallets: function (pageCursor, pageSize, sort, order, enabled, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getEmbeddedWallets(pageCursor, pageSize, sort, order, enabled, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getEmbeddedWallets']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm within a Non-Custodial Wallet
         * @summary Get the public key for a derivation path
         * @param {string} xEndUserWalletId Unique ID of the End-User wallet to the API request. Required for end-user wallet operations.
         * @param {string} walletId The ID of the Non-Custodial wallet
         * @param {string} derivationPath An array of integers (passed as JSON stringified array) representing the full BIP44 derivation path of the requested public key.  The first element must always be 44.
         * @param {GetPublicKeyInfoNcwAlgorithmEnum} algorithm Elliptic Curve
         * @param {boolean} [compressed] Compressed/Uncompressed public key format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfoNcw: function (xEndUserWalletId, walletId, derivationPath, algorithm, compressed, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPublicKeyInfoNcw(xEndUserWalletId, walletId, derivationPath, algorithm, compressed, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.getPublicKeyInfoNcw']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Refresh the balance of an asset in a specific account
         * @summary Refresh asset balance
         * @param {string} walletId Wallet Id
         * @param {string} accountId The ID of the account
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshEmbeddedWalletAssetBalance: function (walletId, accountId, assetId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.refreshEmbeddedWalletAssetBalance(walletId, accountId, assetId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['EmbeddedWalletsApi.refreshEmbeddedWalletAssetBalance']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
    };
};
exports.EmbeddedWalletsApiFp = EmbeddedWalletsApiFp;
/**
 * EmbeddedWalletsApi - factory interface
 * @export
 */
var EmbeddedWalletsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.EmbeddedWalletsApiFp)(configuration);
    return {
        /**
         * Get the addresses of a specific asset, under a specific account, under a specific Non Custodial Wallet
         * @summary Add asset to account
         * @param {EmbeddedWalletsApiAddEmbeddedWalletAssetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmbeddedWalletAsset: function (requestParameters, options) {
            return localVarFp.addEmbeddedWalletAsset(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Create new Non Custodial Wallet
         * @summary Create a new wallet
         * @param {EmbeddedWalletsApiCreateEmbeddedWalletRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedWallet: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.createEmbeddedWallet(requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Create a new account under a specific Non Custodial Wallet
         * @summary Create a new account
         * @param {EmbeddedWalletsApiCreateEmbeddedWalletAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddedWalletAccount: function (requestParameters, options) {
            return localVarFp.createEmbeddedWalletAccount(requestParameters.walletId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a wallet
         * @summary Get a wallet
         * @param {EmbeddedWalletsApiGetEmbeddedWalletRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWallet: function (requestParameters, options) {
            return localVarFp.getEmbeddedWallet(requestParameters.walletId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a specific account under a specific Non Custodial Wallet
         * @summary Get a account
         * @param {EmbeddedWalletsApiGetEmbeddedWalletAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAccount: function (requestParameters, options) {
            return localVarFp.getEmbeddedWalletAccount(requestParameters.walletId, requestParameters.accountId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the addresses of a specific asset, under a specific account, under a specific Non Custodial Wallet
         * @summary Retrieve asset addresses
         * @param {EmbeddedWalletsApiGetEmbeddedWalletAddressesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAddresses: function (requestParameters, options) {
            return localVarFp.getEmbeddedWalletAddresses(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.enabled, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get asset under a specific account, under a specific Non Custodial Wallet
         * @summary Retrieve asset
         * @param {EmbeddedWalletsApiGetEmbeddedWalletAssetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAsset: function (requestParameters, options) {
            return localVarFp.getEmbeddedWalletAsset(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get balance for specific asset, under a specific account
         * @summary Retrieve asset balance
         * @param {EmbeddedWalletsApiGetEmbeddedWalletAssetBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletAssetBalance: function (requestParameters, options) {
            return localVarFp.getEmbeddedWalletAssetBalance(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get specific device for a specific s Wallet
         * @summary Get Embedded Wallet Device
         * @param {EmbeddedWalletsApiGetEmbeddedWalletDeviceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletDevice: function (requestParameters, options) {
            return localVarFp.getEmbeddedWalletDevice(requestParameters.walletId, requestParameters.deviceId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the state of the specific device setup key under a specific Non Custodial Wallet
         * @summary Get device key setup state
         * @param {EmbeddedWalletsApiGetEmbeddedWalletDeviceSetupStateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletDeviceSetupState: function (requestParameters, options) {
            return localVarFp.getEmbeddedWalletDeviceSetupState(requestParameters.walletId, requestParameters.deviceId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get wallet Latest Backup details, including the deviceId, and backup time
         * @summary Get wallet Latest Backup details
         * @param {EmbeddedWalletsApiGetEmbeddedWalletLatestBackupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletLatestBackup: function (requestParameters, options) {
            return localVarFp.getEmbeddedWalletLatestBackup(requestParameters.walletId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets the public key of an asset associated with a specific account within a Non-Custodial Wallet
         * @summary Get the public key of an asset
         * @param {EmbeddedWalletsApiGetEmbeddedWalletPublicKeyInfoForAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletPublicKeyInfoForAddress: function (requestParameters, options) {
            return localVarFp.getEmbeddedWalletPublicKeyInfoForAddress(requestParameters.xEndUserWalletId, requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, requestParameters.change, requestParameters.addressIndex, requestParameters.compressed, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get all the available supported assets for the Non-Custodial Wallet
         * @summary Retrieve supported assets
         * @param {EmbeddedWalletsApiGetEmbeddedWalletSupportedAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWalletSupportedAssets: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getEmbeddedWalletSupportedAssets(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.onlyBaseAssets, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get all Non Custodial Wallets
         * @summary List wallets
         * @param {EmbeddedWalletsApiGetEmbeddedWalletsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddedWallets: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getEmbeddedWallets(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.enabled, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm within a Non-Custodial Wallet
         * @summary Get the public key for a derivation path
         * @param {EmbeddedWalletsApiGetPublicKeyInfoNcwRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfoNcw: function (requestParameters, options) {
            return localVarFp.getPublicKeyInfoNcw(requestParameters.xEndUserWalletId, requestParameters.walletId, requestParameters.derivationPath, requestParameters.algorithm, requestParameters.compressed, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Refresh the balance of an asset in a specific account
         * @summary Refresh asset balance
         * @param {EmbeddedWalletsApiRefreshEmbeddedWalletAssetBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshEmbeddedWalletAssetBalance: function (requestParameters, options) {
            return localVarFp.refreshEmbeddedWalletAssetBalance(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.EmbeddedWalletsApiFactory = EmbeddedWalletsApiFactory;
/**
 * EmbeddedWalletsApi - object-oriented interface
 * @export
 * @class EmbeddedWalletsApi
 * @extends {BaseAPI}
 */
var EmbeddedWalletsApi = /** @class */ (function (_super) {
    __extends(EmbeddedWalletsApi, _super);
    function EmbeddedWalletsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get the addresses of a specific asset, under a specific account, under a specific Non Custodial Wallet
     * @summary Add asset to account
     * @param {EmbeddedWalletsApiAddEmbeddedWalletAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.addEmbeddedWalletAsset = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).addEmbeddedWalletAsset(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Create new Non Custodial Wallet
     * @summary Create a new wallet
     * @param {EmbeddedWalletsApiCreateEmbeddedWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.createEmbeddedWallet = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).createEmbeddedWallet(requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Create a new account under a specific Non Custodial Wallet
     * @summary Create a new account
     * @param {EmbeddedWalletsApiCreateEmbeddedWalletAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.createEmbeddedWalletAccount = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).createEmbeddedWalletAccount(requestParameters.walletId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get a wallet
     * @summary Get a wallet
     * @param {EmbeddedWalletsApiGetEmbeddedWalletRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWallet = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWallet(requestParameters.walletId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get a specific account under a specific Non Custodial Wallet
     * @summary Get a account
     * @param {EmbeddedWalletsApiGetEmbeddedWalletAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWalletAccount = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWalletAccount(requestParameters.walletId, requestParameters.accountId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get the addresses of a specific asset, under a specific account, under a specific Non Custodial Wallet
     * @summary Retrieve asset addresses
     * @param {EmbeddedWalletsApiGetEmbeddedWalletAddressesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWalletAddresses = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWalletAddresses(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.enabled).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get asset under a specific account, under a specific Non Custodial Wallet
     * @summary Retrieve asset
     * @param {EmbeddedWalletsApiGetEmbeddedWalletAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWalletAsset = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWalletAsset(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get balance for specific asset, under a specific account
     * @summary Retrieve asset balance
     * @param {EmbeddedWalletsApiGetEmbeddedWalletAssetBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWalletAssetBalance = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWalletAssetBalance(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get specific device for a specific s Wallet
     * @summary Get Embedded Wallet Device
     * @param {EmbeddedWalletsApiGetEmbeddedWalletDeviceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWalletDevice = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWalletDevice(requestParameters.walletId, requestParameters.deviceId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get the state of the specific device setup key under a specific Non Custodial Wallet
     * @summary Get device key setup state
     * @param {EmbeddedWalletsApiGetEmbeddedWalletDeviceSetupStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWalletDeviceSetupState = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWalletDeviceSetupState(requestParameters.walletId, requestParameters.deviceId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get wallet Latest Backup details, including the deviceId, and backup time
     * @summary Get wallet Latest Backup details
     * @param {EmbeddedWalletsApiGetEmbeddedWalletLatestBackupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWalletLatestBackup = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWalletLatestBackup(requestParameters.walletId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Gets the public key of an asset associated with a specific account within a Non-Custodial Wallet
     * @summary Get the public key of an asset
     * @param {EmbeddedWalletsApiGetEmbeddedWalletPublicKeyInfoForAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWalletPublicKeyInfoForAddress = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWalletPublicKeyInfoForAddress(requestParameters.xEndUserWalletId, requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, requestParameters.change, requestParameters.addressIndex, requestParameters.compressed).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get all the available supported assets for the Non-Custodial Wallet
     * @summary Retrieve supported assets
     * @param {EmbeddedWalletsApiGetEmbeddedWalletSupportedAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWalletSupportedAssets = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWalletSupportedAssets(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.onlyBaseAssets).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get all Non Custodial Wallets
     * @summary List wallets
     * @param {EmbeddedWalletsApiGetEmbeddedWalletsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getEmbeddedWallets = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getEmbeddedWallets(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.enabled).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Gets the public key information based on derivation path and signing algorithm within a Non-Custodial Wallet
     * @summary Get the public key for a derivation path
     * @param {EmbeddedWalletsApiGetPublicKeyInfoNcwRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.getPublicKeyInfoNcw = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).getPublicKeyInfoNcw(requestParameters.xEndUserWalletId, requestParameters.walletId, requestParameters.derivationPath, requestParameters.algorithm, requestParameters.compressed).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Refresh the balance of an asset in a specific account
     * @summary Refresh asset balance
     * @param {EmbeddedWalletsApiRefreshEmbeddedWalletAssetBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddedWalletsApi
     */
    EmbeddedWalletsApi.prototype.refreshEmbeddedWalletAssetBalance = function (requestParameters) {
        var _this = this;
        return (0, exports.EmbeddedWalletsApiFp)(this.configuration).refreshEmbeddedWalletAssetBalance(requestParameters.walletId, requestParameters.accountId, requestParameters.assetId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    return EmbeddedWalletsApi;
}(base_1.BaseAPI));
exports.EmbeddedWalletsApi = EmbeddedWalletsApi;
/**
 * @export
 */
exports.GetEmbeddedWalletAddressesSortEnum = {
    Address: 'address',
    CreatedAt: 'createdAt'
};
/**
 * @export
 */
exports.GetEmbeddedWalletAddressesOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
};
/**
 * @export
 */
exports.GetEmbeddedWalletsSortEnum = {
    CreatedAt: 'createdAt'
};
/**
 * @export
 */
exports.GetEmbeddedWalletsOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
};
/**
 * @export
 */
exports.GetPublicKeyInfoNcwAlgorithmEnum = {
    EcdsaSecp256K1: 'MPC_ECDSA_SECP256K1',
    EcdsaSecp256R1: 'MPC_ECDSA_SECP256R1',
    EddsaEd25519: 'MPC_EDDSA_ED25519'
};
//# sourceMappingURL=embedded-wallets-api.js.map